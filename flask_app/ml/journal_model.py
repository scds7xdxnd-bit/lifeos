class JournalModel:
    def __init__(self):
        # Initialize model parameters and load weights if available
        # Placeholder for account embeddings, language model components, etc.
        self.feedback_counts = {'accept': 0, 'reject': 0}
        self.account_cooccurrence = {}  # simple cooccurrence counters
        self._load_state()

    def _state_path(self):
        import os
        return os.path.join(os.path.dirname(__file__), 'journal_state.json')

    def _load_state(self):
        import json, os
        p = self._state_path()
        if os.path.exists(p):
            try:
                with open(p, 'r') as f:
                    s = json.load(f)
                    self.feedback_counts = s.get('feedback_counts', self.feedback_counts)
                    self.account_cooccurrence = s.get('account_cooccurrence', self.account_cooccurrence)
            except Exception:
                pass

    def _save_state(self):
        import json
        try:
            with open(self._state_path(), 'w') as f:
                json.dump({'feedback_counts': self.feedback_counts, 'account_cooccurrence': self.account_cooccurrence}, f)
        except Exception:
            pass

    def propose_balanced_journals(self, input_data):
        """
        Propose full balanced journal drafts based on the provided input data.
        This stub implementation should:
        1. Ingest descriptions, amounts, and historical patterns to propose drafts.
        2. Use account embeddings learned from prior postings.
        3. Incorporate temporal and contextual signals (period, vendor, project).
        4. Adapt using feedback from journal editor.
        5. Ensure suggestions are balanced (debit/credit sum zero).

        :param input_data: dict with relevant transaction/journal input data
        :return: list of balanced journal drafts
        """
        # Stub: Return a sample balanced journal draft
        sample_draft = {
            'entries': [
                {'account': 'Cash', 'debit': 1000, 'credit': 0},
                {'account': 'Revenue', 'debit': 0, 'credit': 1000}
            ],
            'notes': 'Sample balanced journal entry generated by ML model'
        }
        return [sample_draft]

    def update_with_feedback(self, feedback):
        """
        Update the lightweight model with editor feedback.
        Expected feedback format:
          { 'user_id': int, 'accepted': true/false, 'suggestion': { 'entries': [...] }, 'context': { ... } }
        This stub will update simple counters and co-occurrence counts for accounts appearing together.
        """
        try:
            accepted = bool(feedback.get('accepted'))
            if accepted:
                self.feedback_counts['accept'] += 1
            else:
                self.feedback_counts['reject'] += 1
            suggestion = feedback.get('suggestion') or {}
            entries = suggestion.get('entries') or []
            accounts = [e.get('account') for e in entries if e.get('account')]
            # update cooccurrence
            for i, a in enumerate(accounts):
                for b in accounts[i+1:]:
                    key = tuple(sorted([a, b]))
                    self.account_cooccurrence[key] = self.account_cooccurrence.get(key, 0) + (1 if accepted else 0)
            self._save_state()
            # Possibly trigger lightweight incremental training
            try:
                train_res = self.maybe_train_on_feedback()
            except Exception:
                train_res = {'ok': False}
            return { 'ok': True, 'saved': True, 'train': train_res }
        except Exception as e:
             return { 'ok': False, 'error': str(e) }

    def train_incremental_mf(self, epochs=5, factors=8, reg=0.1):
        """
        Lightweight incremental matrix factorization on the account cooccurrence counts.
        This builds embeddings for accounts using simple alternating least squares (ALS)-style updates.
        The method is intentionally small and depends only on numpy.
        """
        try:
            import numpy as np
            # Build index mapping
            keys = list(self.account_cooccurrence.keys())
            accounts = set()
            for k in keys:
                accounts.update(k)
            accounts = sorted(accounts)
            if not accounts:
                return {'ok': False, 'error': 'No accounts to train on'}
            idx = {a:i for i,a in enumerate(accounts)}
            n = len(accounts)
            # Build symmetric cooccurrence matrix
            M = np.zeros((n,n), dtype=float)
            for (a,b),v in self.account_cooccurrence.items():
                if a in idx and b in idx:
                    i,j = idx[a], idx[b]
                    M[i,j] = v
                    M[j,i] = v
            # Initialize embeddings
            X = np.random.normal(scale=0.01, size=(n,factors))
            Y = np.random.normal(scale=0.01, size=(n,factors))
            I = np.eye(factors)
            for ep in range(epochs):
                # Update X
                for i in range(n):
                    # Solve (Y^T W Y + reg I) x = Y^T W m
                    w = M[i,:]
                    W = np.diag(w)
                    A = Y.T @ W @ Y + reg * I
                    b = Y.T @ (W @ M[i,:])
                    # Regularize
                    try:
                        X[i,:] = np.linalg.solve(A, b)
                    except np.linalg.LinAlgError:
                        X[i,:] = np.linalg.lstsq(A, b, rcond=None)[0]
                # Update Y symmetrically
                for j in range(n):
                    w = M[:,j]
                    W = np.diag(w)
                    A = X.T @ W @ X + reg * I
                    b = X.T @ (W @ M[:,j])
                    try:
                        Y[j,:] = np.linalg.solve(A, b)
                    except np.linalg.LinAlgError:
                        Y[j,:] = np.linalg.lstsq(A, b, rcond=None)[0]
            # Save embeddings mapping
            emb = { a: X[idx[a]].tolist() for a in accounts }
            import json, os
            p = os.path.join(os.path.dirname(__file__), 'account_embeds.json')
            with open(p, 'w') as f:
                json.dump({'accounts': accounts, 'embeddings': emb}, f)
            self.account_embeddings = emb
            return {'ok': True, 'trained_on': len(accounts)}
        except Exception as e:
            return {'ok': False, 'error': str(e)}

    def maybe_train_on_feedback(self, threshold=5):
        """
        Trigger incremental trainer when accepted feedback count reaches threshold since last training.
        For this stub, we'll use feedback_counts['accept'] as a crude trigger and then reset a counter.
        """
        try:
            # Use accept count as trigger
            if self.feedback_counts.get('accept', 0) >= threshold:
                res = self.train_incremental_mf()
                # reset accept counter
                self.feedback_counts['accept'] = 0
                self._save_state()
                return res
            return {'ok': False, 'reason': 'threshold not reached'}
        except Exception as e:
            return {'ok': False, 'error': str(e)}
